local blessCurseManagerApi          = require("chaosbag/BlessCurseManagerApi")
local guidReferenceApi              = require("core/GUIDReferenceApi")
local mythosAreaApi                 = require("core/MythosAreaApi")
local navigationOverlayApi          = require("core/NavigationOverlayApi")
local playAreaApi                   = require("core/PlayAreaApi")
local playermatApi                  = require("playermat/PlayermatApi")
local searchLib                     = require("util/SearchLib")
local soundCubeApi                  = require("core/SoundCubeApi")
local tokenArrangerApi              = require("accessories/TokenArrangerApi")
local tokenChecker                  = require("core/token/TokenChecker")
local tokenSpawnTrackerApi          = require("core/token/TokenSpawnTrackerApi")

---------------------------------------------------------
-- general setup
---------------------------------------------------------

ENCOUNTER_DECK_POS                  = { -3.93, 1, 5.76 }
ENCOUNTER_DECK_DISCARD_POSITION     = { -3.85, 1, 10.38 }

-- GUIDs that will not be interactable (e.g. parts of the table)
local NOT_INTERACTABLE              = {
  "6161b4", -- Decoration-Map
  "9f334f", -- MythosArea
  "463022", -- Panel behind tentacle stand
  "f182ee", -- InvestigatorCount
  "7bff34", -- Tentacle stand
  "8646eb", -- horizontal border left
  "75937e", -- horizontal border right
  "612072", -- vertical border left
  "975c39", -- vertical border right
}

local chaosTokens                   = {}
local chaosTokensLastMatGUID        = nil

-- chaos token stat tracking
local tokenDrawingStats             = { ["Overall"] = {} }

local bagSearchers                  = {}
local hideTitleSplashWaitFunctionId = nil

-- online functionality related variables
local MOD_VERSION                   = "4.0.0"
local SOURCE_REPO                   = "https://github.com/Chr1Z93/SCED-downloads/releases/latest/download/"
local library, requestObj, modMeta, searchFilter, authorFilter
local acknowledgedUpgradeVersions   = {}
local authorList                    = {}
local contentToShow                 = "campaign"
local currentListItem               = 1
local tabIdTable                    = {
  tab1 = "campaign",
  tab2 = "scenario",
  tab3 = "fanmade-campaign",
  tab4 = "fanmade-scenario",
  tab5 = "fanmade-playercards"
}

-- optionPanel data (intentionally not local!)
optionPanel                         = {}
local LANGUAGES                     = {
  { code = "zh_CN", name = "简体中文" },
  { code = "zh_TW", name = "繁體中文" },
  { code = "de", name = "Deutsch" },
  { code = "en", name = "English" },
  { code = "es", name = "Español" },
  { code = "fr", name = "Français" },
  { code = "it", name = "Italiano" }
}
local RESOURCE_OPTIONS              = {
  "enabled",
  "custom",
  "disabled"
}

-- track player-specific visibilities
local handVisibility                = {}
local blurseVisibility              = {}

---------------------------------------------------------
-- data for tokens
---------------------------------------------------------

ID_URL_MAP                          = {
  ['blue']    = { name = "Elder Sign", url = 'https://i.imgur.com/nEmqjmj.png' },
  ['p1']      = { name = "+1", url = 'https://i.imgur.com/uIx8jbY.png' },
  ['0']       = { name = "0", url = 'https://i.imgur.com/btEtVfd.png' },
  ['m1']      = { name = "-1", url = 'https://i.imgur.com/w3XbrCC.png' },
  ['m2']      = { name = "-2", url = 'https://i.imgur.com/bfTg2hb.png' },
  ['m3']      = { name = "-3", url = 'https://i.imgur.com/yfs8gHq.png' },
  ['m4']      = { name = "-4", url = 'https://i.imgur.com/qrgGQRD.png' },
  ['m5']      = { name = "-5", url = 'https://i.imgur.com/3Ym1IeG.png' },
  ['m6']      = { name = "-6", url = 'https://i.imgur.com/c9qdSzS.png' },
  ['m7']      = { name = "-7", url = 'https://i.imgur.com/4WRD42n.png' },
  ['m8']      = { name = "-8", url = 'https://i.imgur.com/9t3rPTQ.png' },
  ['skull']   = { name = "Skull", url = 'https://i.imgur.com/stbBxtx.png' },
  ['cultist'] = { name = "Cultist", url = 'https://i.imgur.com/VzhJJaH.png' },
  ['tablet']  = { name = "Tablet", url = 'https://i.imgur.com/1plY463.png' },
  ['elder']   = { name = "Elder Thing", url = 'https://i.imgur.com/ttnspKt.png' },
  ['red']     = { name = "Auto-fail", url = 'https://i.imgur.com/lns4fhz.png' },
  ['bless']   = { name = "Bless", url = 'https://steamusercontent-a.akamaihd.net/ugc/1655601092778627699/339FB716CB25CA6025C338F13AFDFD9AC6FA8356/' },
  ['curse']   = { name = "Curse", url = 'https://steamusercontent-a.akamaihd.net/ugc/1655601092778636039/2A25BD38E8C44701D80DD96BF0121DA21843672E/' },
  ['frost']   = { name = "Frost", url = 'https://steamusercontent-a.akamaihd.net/ugc/1858293462583104677/195F93C063A8881B805CE2FD4767A9718B27B6AE/' }
}

TokenManager                        = {}
local tokenOffsets                  = {}

-- Table of data extracted from the token source bag, keyed by the Memo on each token which
-- should match the token type keys ("resource", "clue", etc)
local tokenTemplates
local playerCardData, locationData

-- stateIDs for the multi-stated resource tokens
local stateTable                    = {
  ["resource"] = 1,
  ["ammo"]     = 2,
  ["bounty"]   = 3,
  ["charge"]   = 4,
  ["evidence"] = 5,
  ["secret"]   = 6,
  ["supply"]   = 7,
  ["offering"] = 8
}

---------------------------------------------------------
-- general code
---------------------------------------------------------

-- saving state of optionPanel to restore later
function onSave()
  local chaosTokensGUID = {}
  for _, obj in ipairs(chaosTokens) do
    if obj ~= nil then
      table.insert(chaosTokensGUID, obj.getGUID())
    end
  end

  return JSON.encode({
    acknowledgedUpgradeVersions = acknowledgedUpgradeVersions,
    chaosTokensLastMatGUID      = chaosTokensLastMatGUID,
    chaosTokensGUID             = chaosTokensGUID,
    blurseVisibility            = blurseVisibility,
    handVisibility              = handVisibility,
    optionPanel                 = optionPanel
  })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData            = JSON.decode(savedData)
    acknowledgedUpgradeVersions = loadedData.acknowledgedUpgradeVersions
    chaosTokensLastMatGUID      = loadedData.chaosTokensLastMatGUID
    blurseVisibility            = loadedData.blurseVisibility
    handVisibility              = loadedData.handVisibility
    optionPanel                 = loadedData.optionPanel

    -- restore saved state for drawn chaos tokens
    for _, guid in ipairs(loadedData.chaosTokensGUID or {}) do
      table.insert(chaosTokens, getObjectFromGUID(guid))
    end

    updateOptionPanelState()
  end

  for _, guid in ipairs(NOT_INTERACTABLE) do
    local obj = getObjectFromGUID(guid)
    if obj ~= nil then obj.interactable = false end
  end

  getModVersion()
  updateHandVisibility()
  updateBlurseVisibility()
  math.randomseed(os.time())
  TokenManager.initialiize()

  -- initialization of loadable objects library (delay to let Navigation Overlay build)
  Wait.time(function()
    WebRequest.get(SOURCE_REPO .. 'library.json', libraryDownloadCallback)
  end, 1)
end

-- provides a random seed (from 1 to 999) to be used by "linked" objects like the action tokens
function getRandomSeed()
  return math.random(999)
end

-- Event hook for any object search. When chaos tokens are manipulated while the chaos bag
-- container is being searched, a TTS bug can cause tokens to duplicate or vanish. We lock the
-- chaos bag during search operations to avoid this.
function onObjectSearchStart(object, playerColor)
  local chaosBag = findChaosBag()
  if object == chaosBag then
    bagSearchers[playerColor] = true
  end
end

-- Event hook for any object search. When chaos tokens are manipulated while the chaos bag
-- container is being searched, a TTS bug can cause tokens to duplicate or vanish. We lock the
-- chaos bag during search operations to avoid this.
function onObjectSearchEnd(object, playerColor)
  local chaosBag = findChaosBag()
  if object == chaosBag then
    bagSearchers[playerColor] = nil
  end
  Player[playerColor].clearSelectedObjects()
end

-- Pass object enter container events to the PlayArea to clear vector lines from dragged cards.
-- This requires the try method as cards won't exist any more after they enter a deck, so the lines
-- can't be cleared.
function tryObjectEnterContainer(container, object)
  -- stop mini cards from forming decks
  if object.hasTag("Minicard") and container.hasTag("Minicard") then
    return false
  end

  playAreaApi.tryObjectEnterContainer(container, object)
  return true
end

-- TTS event for objects that enter zones
function onObjectEnterZone(zone, object)
  -- detect the "token discard zones" beneath the hand zones
  if zone.getName() == "TokenDiscardZone" and
      not tokenChecker.isChaosToken(object) and
      object.type == "Tile" and
      object.getMemo() and
      not object.getLock() then
    local matcolor = playermatApi.getMatColorByPosition(object.getPosition())
    local trash = guidReferenceApi.getObjectByOwnerAndType(matcolor, "Trash")
    trash.putObject(object)
  elseif zone.type == "Hand" and object.type == "Card" then
    -- make sure the card is face-up
    if object.is_face_down then
      object.flip()
    end

    -- disable any helpers on the card
    if object.hasTag("CardWithHelper") then
      object.call("setHelperState", false)
    end

    -- maybe reset data about sealed tokens (if that function exists)
    if object.hasTag("CardThatSeals") then
      local func = object.getVar("resetSealedTokens")
      if func ~= nil then
        object.call("resetSealedTokens")
      end
    end

    applyHidingToCard(object, zone.getValue())
  end
end

-- TTS event for objects that leave zones
function onObjectLeaveZone(zone, object)
  -- 1 frame delay to avoid error messages when exiting the game
  Wait.frames(
    function()
      -- end here if one of the objects doesn't exist
      if zone.isDestroyed() or object.isDestroyed() then return end

      -- resync the state of the helper on the card with the option panel
      if zone.type == "Hand" and object.hasTag("CardWithHelper") then
        object.call("syncDisplayWithOptionPanel")
      end

      -- make object visible
      object.setHiddenFrom({})
    end, 1)
end

-- handle card drawing via number typing for multihanded gameplay
-- (and additionally allow Norman Withers to draw multiple cards via number)
function onObjectNumberTyped(hoveredObject, playerColor, number)
  -- only continue for decks or cards
  if hoveredObject.type ~= "Deck" and hoveredObject.type ~= "Card" then return end

  -- check if this is a card with states (and then change state instead of drawing it)
  local states = hoveredObject.getStates()
  if states ~= nil and #states > 0 then
    local stateId = hoveredObject.getStateId()
    if stateId ~= number and (#states + 1) >= number then
      hoveredObject.setState(number)
      return true
    end
  end

  -- check whether the hovered object is part of a players draw objects
  for color, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
    local deckAreaObjects = playermatApi.getDeckAreaObjects(color)
    if deckAreaObjects.topCard == hoveredObject or deckAreaObjects.draw == hoveredObject then
      playermatApi.drawCardsWithReshuffle(color, number)
      return true
    end
  end
end

-- disable delete action (only applies to promoted players) and discard objects instead
function onPlayerAction(player, action, targets)
  if action == Player.Action.Delete and not player.admin then
    for _, target in ipairs(targets) do
      local matColor = playermatApi.getMatColorByPosition(target.getPosition())
      local trash = guidReferenceApi.getObjectByOwnerAndType(matColor, "Trash")
      trash.putObject(target)
    end
    return false
  end
  return true
end

---------------------------------------------------------
-- chaos token drawing
---------------------------------------------------------

-- checks scripting zone for chaos bag (also called by a lot of objects!)
function findChaosBag()
  local chaosBagZone = guidReferenceApi.getObjectByOwnerAndType("Mythos", "ChaosBagZone")

  -- error handling: scripting zone not found
  if chaosBagZone == nil then
    printToAll("Zone for chaos bag detection couldn't be found.", "Red")
    return
  end

  for _, item in ipairs(chaosBagZone.getObjects()) do
    if item.getDescription() == "Chaos Bag" then
      return item
    end
  end

  -- error handling: chaos bag not found
  printToAll("Chaos bag couldn't be found.", "Red")
end

-- returns all chaos tokens to the bag
function returnChaosTokens()
  local chaosBag = findChaosBag()
  for _, token in pairs(chaosTokens) do
    if token ~= nil then chaosBag.putObject(token) end
  end
  chaosTokens = {}
  isTokenXMLActive = false
end

-- returns a single chaos token to the bag and calls respective functions
function returnChaosTokenToBag(params)
  local name = params.token.getName()
  local chaosBag = findChaosBag()
  chaosBag.putObject(params.token)
  tokenArrangerApi.layout()
  if name == "Bless" or name == "Curse" then
    blessCurseManagerApi.releasedToken(name, params.token.getGUID(), params.fromBag)
  end
end

-- returns the index of a token in the chaosTokens table
function getTokenIndex(token)
  for i, obj in ipairs(chaosTokens) do
    if obj == token then
      return i
    end
  end
end

-- starts a redraw effect and displays buttons for a choice if needed
function activeRedrawEffect(params)
  redrawData = params

  if isTokenXMLActive == true then
    broadcastToAll("Clear already active buttons first, then try again", "Red")
    return
  end

  if #chaosTokens == 0 then
    broadcastToAll("No tokens found in play area", "Red")
    return
  end

  -- nil handling
  redrawData.validTokens = redrawData.validTokens or {}
  redrawData.invalidTokens = redrawData.invalidTokens or {}

  -- determine if only some tokens are able to be returned to the bag
  local matchingTokensInPlay = {}
  for _, token in ipairs(chaosTokens) do
    local tokenName = getReadableTokenName(token.getName())

    -- allow valid tokens or not invalid tokens, also allow any token if both lists empty
    if (redrawData.validTokens[tokenName] ~= nil and isTableEmpty(redrawData.invalidTokens)) or
        (isTableEmpty(redrawData.validTokens) and not redrawData.invalidTokens[tokenName]) or
        (isTableEmpty(redrawData.validTokens) and isTableEmpty(redrawData.invalidTokens)) then
      table.insert(matchingTokensInPlay, token)
    end
  end

  -- proceed according to number of matching tokens
  if #matchingTokensInPlay == 0 then
    broadcastToAll("No eligible token found in play area", "Red")
  elseif #matchingTokensInPlay == 1 then
    returnAndRedraw(_, matchingTokensInPlay[1].getGUID())
  else
    -- draw XML to allow choosing the token to return to bag
    isTokenXMLActive = true
    for _, token in ipairs(matchingTokensInPlay) do
      token.UI.setXmlTable({
        {
          tag = "VerticalLayout",
          attributes = {
            height = 275,
            width = 275,
            padding = "0 0 20 25",
            scale = "0.4 0.4 1",
            rotation = "0 0 180",
            position = "0 0 -15",
            color = "rgba(0,0,0,0.7)",
            onClick = "Global/returnAndRedraw(" .. token.getGUID() .. ")",
          },
          children = {
            {
              tag = "Text",
              attributes = {
                fontSize = "100",
                font = "font_teutonic-arkham",
                color = "#ffffff",
                text = "Redraw"
              }
            },
            {
              tag = "Text",
              attributes = {
                fontSize = "125",
                font = "font_arkhamicons",
                color = "#ffffff",
                text = "u"
              }
            }
          }
        }
      })
    end
  end
end

-- returns a chaos token to the chaos bag and redraws another
function returnAndRedraw(_, tokenGUID)
  local returnedToken = getObjectFromGUID(tokenGUID)
  local tokenName = returnedToken.getName()
  local indexOfReturnedToken = getTokenIndex(returnedToken)
  local matColor = playermatApi.getMatColorByPosition(returnedToken.getPosition())
  local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")

  local takeParameters = {
    position = returnedToken.getPosition(),
    rotation = returnedToken.getRotation()
  }

  if #chaosTokens > indexOfReturnedToken then
    takeParameters.rotation = takeParameters.rotation + Vector(0, 0, -8)
  end

  -- perform the actual token replacing
  trackChaosToken(tokenName, mat.getGUID(), true)
  local params = { token = returnedToken, fromBag = true }
  returnChaosTokenToBag(params)

  chaosTokens[indexOfReturnedToken] = drawChaosToken({
    mat = mat,
    drawAdditional = true,
    tokenType = redrawData.drawSpecificToken, -- currently only used for Nkosi Mabati
    takeParameters = takeParameters
  })

  -- remove these tokens from the bag
  if redrawData.returnToPool then
    -- let the bless/curse manager handle these
    if tokenName == "Bless" or tokenName == "Curse" then
      blessCurseManagerApi.removeToken(tokenName)
    else
      local invertedTable = createChaosTokenNameLookupTable()
      removeChaosToken(invertedTable[tokenName])
    end
  end

  -- remove XML from tokens in play
  isTokenXMLActive = false
  for _, token in ipairs(chaosTokens) do
    token.UI.setXml("")
  end

  redrawData = {}

  -- return a reference to the freshly drawn token
  return chaosTokens[indexOfReturnedToken]
end

-- Checks to see if the chaos bag can be manipulated. If a player is searching the bag when tokens
-- are drawn or replaced a TTS bug can cause those tokens to vanish. Any functions which change the
-- contents of the bag should check this method before doing so.
-- This method will broadcast a message to all players if the bag is being searched.
---@return boolean: True if the bag is manipulated, false if it should be blocked.
function canTouchChaosTokens()
  for _, searching in pairs(bagSearchers) do
    if searching then
      broadcastToAll("Someone is searching the chaos bag, can't touch the tokens.", "Red")
      return false
    end
  end
  return true
end

-- converts the human readable name to the empty name that the bag uses
function getChaosTokenName(tokenName)
  if tokenName == "Custom Token" then
    tokenName = ""
  end
  return tokenName
end

-- converts the empty name to the human readable name
function getReadableTokenName(tokenName)
  if tokenName == "" then
    tokenName = "Custom Token"
  end
  return tokenName
end

-- called by playermats (by the "Draw chaos token" button)
function drawChaosToken(params)
  if not canTouchChaosTokens() then return end

  local matGUID = params.mat.getGUID()

  -- return token(s) on other playermat first
  if chaosTokensLastMatGUID ~= nil and chaosTokensLastMatGUID ~= matGUID and #chaosTokens ~= 0 then
    returnChaosTokens()
    chaosTokensLastMatGUID = nil
    return
  end

  chaosTokensLastMatGUID = matGUID

  -- if we have left clicked and have no tokens OR if we have right clicked
  if params.drawAdditional or #chaosTokens == 0 then
    local chaosBag = findChaosBag()
    if #chaosBag.getObjects() == 0 then return end
    chaosBag.shuffle()

    -- add the token to the list, compute new position based on list length
    local tokenOffset = Vector(-1.55 + 0.17 * #chaosTokens, 0.25, -0.58)
    local takeParameters = params.takeParameters or {}
    takeParameters.position = takeParameters.position or params.mat.positionToWorld(tokenOffset)
    takeParameters.rotation = takeParameters.rotation or params.mat.getRotation()

    local token
    if params.guidToBeResolved then
      -- resolve a sealed token from a card
      token = getObjectFromGUID(params.guidToBeResolved)
      token.setPositionSmooth(takeParameters.position)
      tokenArrangerApi.layout()

      local tokenName = token.getName()
      if tokenName == "Bless" or tokenName == "Curse" then
        blessCurseManagerApi.releasedToken(tokenName, token.getGUID())
      end
    else
      -- take a token from the bag, either specified or random
      if params.tokenType then
        for i, lookedForToken in ipairs(chaosBag.getObjects()) do
          if lookedForToken.nickname == params.tokenType then
            takeParameters.index = i - 1
          end
        end
      end
      token = chaosBag.takeObject(takeParameters)
    end

    -- get data for token description
    local name = token.getName()
    local tokenData = mythosAreaApi.returnTokenData().tokenData or {}
    local specificData = tokenData[name] or {}
    token.setDescription(specificData.description or "")
    trackChaosToken(name, matGUID)

    if not params.takeParameters then
      table.insert(chaosTokens, token)
    end
    return token
  else
    returnChaosTokens()
  end
end

---------------------------------------------------------
-- token spawning
---------------------------------------------------------

-- DEPRECATED. Use TokenManager instead --> TODO: Remove this with the new downloads repo (v.4.0.0)
-- Spawns a single token.
---@param params table Array with arguments to the method. 1 = position, 2 = type, 3 = rotation
function spawnToken(params)
  return TokenManager.spawnToken({
    position = params[1],
    tokenType = params[2],
    rotation = params[3]
  })
end

---------------------------------------------------------
-- chaos token stat tracker
---------------------------------------------------------

function trackChaosToken(tokenName, matGUID, subtract)
  -- initialize tables
  if not tokenDrawingStats[matGUID] then tokenDrawingStats[matGUID] = {} end

  -- increase stats by 1 (or decrease if token is returned)
  local modifier                          = (subtract and -1 or 1)
  tokenName                               = getReadableTokenName(tokenName)
  tokenDrawingStats["Overall"][tokenName] = (tokenDrawingStats["Overall"][tokenName] or 0) + modifier
  tokenDrawingStats[matGUID][tokenName]   = (tokenDrawingStats[matGUID][tokenName] or 0) + modifier
end

-- Left-click: print stats, Right-click: reset stats
function handleStatTrackerClick(_, _, isRightClick)
  if isRightClick then
    resetChaosTokenStatTracker()
  else
    local squidKing     = "Nobody"
    local maxSquid      = 0
    local foundAnyStats = false

    for key, personalStats in pairs(tokenDrawingStats) do
      local playerColor, playerName

      if key == "Overall" then
        playerColor = "White"
        playerName = "Overall"
      else
        local matColor = playermatApi.getMatColorByPosition(getObjectFromGUID(key).getPosition())
        playerColor = playermatApi.getPlayerColor(matColor)
        playerName = Player[playerColor].steam_name or playerColor

        local playerSquidCount = personalStats["Auto-fail"] or 0
        if playerSquidCount > maxSquid then
          squidKing = playerName
          maxSquid = playerSquidCount
        end
      end

      -- get the total count of drawn tokens for the player
      local totalCount = 0
      for _, value in pairs(personalStats) do
        totalCount = totalCount + value
      end

      -- only print the personal stats if any tokens were drawn
      if totalCount > 0 then
        foundAnyStats = true
        printToAll("------------------------------")
        printToAll(playerName .. " Stats", playerColor)

        -- print stats in order of the "ID_URL_MAP"
        for _, subtable in pairs(ID_URL_MAP) do
          local tokenName = subtable.name
          local value = personalStats[tokenName]
          if value and value ~= 0 then
            printToAll(tokenName .. ': ' .. tostring(value))
          end
        end

        -- also print stats for custom tokens
        local customTokenName = getReadableTokenName("")
        local customTokenCount = personalStats[customTokenName]
        if customTokenCount and customTokenCount ~= 0 then
          printToAll(customTokenName .. ': ' .. tostring(customTokenCount))
        end

        printToAll('Total: ' .. tostring(totalCount))
      end
    end

    -- detect if any player drew tokens
    if foundAnyStats then
      printToAll("------------------------------")
      printToAll(squidKing .. " is an auto-fail magnet.", { 255, 0, 0 })
    else
      printToAll("No tokens have been drawn yet.", "Yellow")
    end
  end
end

-- resets the count for each token to 0
function resetChaosTokenStatTracker()
  tokenDrawingStats = { ["Overall"] = {} }
end

---------------------------------------------------------
-- Difficulty selector script
---------------------------------------------------------

-- called for button creation on the difficulty selectors
---@param args table Parameters for this function:
-- object   TTSObject   Usually "self"
-- key      String      Name of the scenario
function createSetupButtons(args)
  local data = getDataValue('modeData', args.key)
  if data ~= nil then
    local buttonParameters          = {}
    buttonParameters.function_owner = args.object
    buttonParameters.position       = { 0, 0.1, -0.15 }
    buttonParameters.scale          = { 0.47, 1, 0.47 }
    buttonParameters.height         = 200
    buttonParameters.width          = 1150
    buttonParameters.color          = { 0.87, 0.8, 0.7 }

    if data.easy ~= nil then
      buttonParameters.label = "Easy"
      buttonParameters.click_function = "easyClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.normal ~= nil then
      buttonParameters.label = "Standard"
      buttonParameters.click_function = "normalClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.hard ~= nil then
      buttonParameters.label = "Hard"
      buttonParameters.click_function = "hardClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.expert ~= nil then
      buttonParameters.label = "Expert"
      buttonParameters.click_function = "expertClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.standalone ~= nil then
      buttonParameters.label = "Standalone"
      buttonParameters.click_function = "standaloneClick"
      args.object.createButton(buttonParameters)
    end
  end
end

-- called for adding chaos tokens
---@param args table Parameters for this function:
-- object object  Usually "self"
-- key    string  Name of the scenario
-- mode   string  difficulty (e.g. "hard" or "expert")
function fillContainer(args)
  local data = getDataValue('modeData', args.key)
  if data == nil then return end

  local value = data[args.mode]
  if value == nil or value.token == nil then return end

  local tokenList = {}

  for _, tokenId in ipairs(value.token) do
    table.insert(tokenList, tokenId)
  end

  if value.append ~= nil then
    for _, tokenId in ipairs(value.append) do
      table.insert(tokenList, tokenId)
    end
  end

  -- randomly choose tokens for specific Carcosa scenarios in standalone
  if value.random then
    local n = #value.random
    if n > 0 then
      for _, tokenId in ipairs(value.random[math.random(1, n)]) do
        table.insert(tokenList, tokenId)
      end
    end
  end

  setChaosBagState(tokenList)

  if value.message then
    broadcastToAll(value.message)
  end

  if value.warning then
    broadcastToAll(value.warning, { 1, 0.5, 0.5 })
  end
end

function getDataValue(storage, key)
  local DATA_HELPER = guidReferenceApi.getObjectByOwnerAndType("Mythos", "DataHelper")
  local data = DATA_HELPER.getTable(storage)
  if data ~= nil then
    local value = data[key]
    if value ~= nil then
      local res = {}
      for m, v in pairs(value) do
        res[m] = v
        if res[m].parent ~= nil then
          local parentData = getDataValue(storage, res[m].parent)
          if parentData ~= nil and parentData[m] ~= nil and parentData[m].token ~= nil then
            res[m].token = parentData[m].token
          end
          res[m].parent = nil
        end
      end
      return res
    end
  end
end

function createChaosTokenNameLookupTable()
  local namesToIds = {}
  for k, v in pairs(ID_URL_MAP) do
    namesToIds[v.name] = k
  end
  return namesToIds
end

-- returns the currently drawn chaos tokens
---@api ChaosBagApi
function getChaosTokensinPlay()
  return chaosTokens
end

-- returns a table of chaos token ids in the current chaos bag
---@api ChaosBag / ChaosBagApi
function getChaosBagState()
  local tokens = {}
  local invertedTable = createChaosTokenNameLookupTable()
  local chaosBag = findChaosBag()

  for _, v in ipairs(chaosBag.getObjects()) do
    local id = invertedTable[v.name]
    if id then
      table.insert(tokens, id)
    else
      printToAll(v.name .. " token not recognized. Will not be recorded.", "Yellow")
    end
  end

  return tokens
end

-- respawns the chaos bag with a new state of tokens
---@param tokenList table List of chaos token ids
---@api ChaosBag / ChaosBagApi
function setChaosBagState(tokenList)
  if not canTouchChaosTokens() then return end

  local chaosBag = findChaosBag()
  local chaosBagData = chaosBag.getData()
  local reserveData = getObjectFromGUID("106418").getData()
  local tokenCache = {}
  local containedObjects = {}

  -- create a temporary copy of the data for each chaos token
  for _, objData in ipairs(reserveData.ContainedObjects) do
    tokenCache[objData.Nickname] = objData
  end

  -- iterate over tokenlist and insert specified tokens into new table
  for _, tokenId in ipairs(tokenList) do
    local tokenName = ID_URL_MAP[tokenId].name
    table.insert(containedObjects, tokenCache[tokenName])
  end

  -- overwrite chaos bag content and respawn it
  chaosBagData.ContainedObjects = containedObjects
  chaosBag.destruct()
  spawnObjectData({ data = chaosBagData })

  -- remove tokens that are still in play
  for _, token in pairs(chaosTokens) do
    if token ~= nil then token.destruct() end
  end
  chaosTokens = {}
  chaosTokensLastMatGUID = nil

  -- reset bless / curse manager
  blessCurseManagerApi.removeTakenTokensAndReset()

  printToAll("Chaos Bag set to chosen difficulty.", "Green")
end

-- spawns the specified chaos token and puts it into the chaos bag
---@param id string ID of the chaos token
function spawnChaosToken(id)
  if not canTouchChaosTokens() then return end

  id = id:lower()
  local chaosBag = findChaosBag()
  local url = ID_URL_MAP[id].url or ""

  if url ~= "" then
    return spawnObject({
      type = 'Custom_Tile',
      position = { 0.49, 3, 0 },
      scale = { 0.81, 1.0, 0.81 },
      rotation = { 0, 270, 0 },
      callback_function = function(obj)
        obj.setName(ID_URL_MAP[id].name)
        chaosBag.putObject(obj)
        tokenArrangerApi.layout()
      end
    }).setCustomObject({
      type = 2,
      image = url,
      thickness = 0.1
    })
  end
end

-- removes the specified chaos token from the chaos bag
---@param id string ID of the chaos token
function removeChaosToken(id)
  if not canTouchChaosTokens() then return end

  local tokens = {}
  local chaosBag = findChaosBag()
  local name = ID_URL_MAP[id].name

  for _, v in ipairs(chaosBag.getObjects()) do
    if v.name == name then table.insert(tokens, v.guid) end
  end

  -- error handling: no matching token found
  if #tokens == 0 then
    printToAll("No " .. name .. " tokens in the chaos bag.", "Yellow")
    return
  end

  chaosBag.takeObject({
    guid = tokens[1],
    smooth = false,
    callback_function = function(obj)
      obj.destruct()
      tokenArrangerApi.layout()
    end
  })
  printToAll("Removing " .. name .. " token (in bag: " .. #tokens - 1 .. ")", "White")
end

-- returns all sealed tokens on cards to the chaos bag
function releaseAllSealedTokens(playerColor)
  for _, obj in ipairs(getObjectsWithTag("CardThatSeals")) do
    obj.call("releaseAllTokens", playerColor)
  end
end

---------------------------------------------------------
-- Content Importing and XML functions
---------------------------------------------------------

-- callback function for the search field in the download menu
function onSearchValueSubmit(_, value)
  -- this event seems to be called 5x at once, so we use this flag to just execute it once
  if ignoreSubmit then return end
  ignoreSubmit = true

  -- store input value in global var
  if value == "" then
    searchFilter = nil
  else
    searchFilter = value
  end

  -- update XML so that the settings persists
  UI.setAttribute("searchField", "text", value)

  -- turn off flag after 0.1s
  Wait.time(function() ignoreSubmit = false end, 0.1)

  -- update list (including new filter setting)
  updateDownloadItemList(true)
end

-- callback function for the "author" dropdown in the download menu
function onAuthorFilterChanged(_, value)
  -- store input value in global var
  if value == "All authors" then
    authorFilter = nil
  else
    authorFilter = value
  end

  -- update XML so that the settings persists
  UI.setAttribute("authorDropdown", "value", returnAuthorId(value))

  -- update list (including new filter setting)
  updateDownloadItemList(true)
end

-- helper function to get the ID of the dropdown selection
function returnAuthorId(name)
  for index, optionName in ipairs(authorList) do
    if optionName == name then
      return index
    end
  end
end

-- forwards the requested content type to the update function and sets highlight to clicked tab
---@param tabId string Id of the clicked tab
function onClick_tab(_, _, tabId)
  for listId, listContent in pairs(tabIdTable) do
    if listId == tabId then
      UI.setClass(listId, 'downloadTab activeTab')
      contentToShow = listContent
    else
      UI.setClass(listId, 'downloadTab')
    end
  end
  currentListItem = 1

  -- reset filters
  authorFilter, searchFilter = nil, nil
  UI.setAttribute("searchField", "text", "")
  UI.setAttribute("authorDropdown", "value", 0)

  updateDownloadItemList()
end

-- click function for the items in the download window
-- updates backgroundcolor for row panel and fontcolor for list item
function onClick_select(_, _, identificationKey)
  UI.setAttribute("panel" .. currentListItem, "color", "clear")
  UI.setAttribute(contentToShow .. "_" .. currentListItem, "color", "white")

  -- parses the identification key (contentToShow_currentListItem)
  if identificationKey then
    contentToShow = nil
    currentListItem = nil
    for str in string.gmatch(identificationKey, "([^_]+)") do
      if not contentToShow then
        -- grab the first part to know the content type
        contentToShow = str
      else
        -- get the index
        currentListItem = tonumber(str)
        break
      end
    end
  end

  UI.setAttribute("panel" .. currentListItem, "color", "grey")
  UI.setAttribute(contentToShow .. "_" .. currentListItem, "color", "black")
  updatePreviewWindow()
end

-- click function for the "Custom URL" button in the playarea image gallery
function onClick_customUrl(player)
  changeWindowVisibilityForColor(player.color, "playareaGallery")
  Wait.time(function()
    player.showInputDialog("Enter a custom URL for the playarea image", "", function(newURL)
      playAreaApi.updateSurface(newURL)
    end)
  end, 0.15)
end

-- click function for the download button in the preview window
function onClick_download(player)
  local params = library[contentToShow][currentListItem]
  params.player = player
  placeholder_download(params)
end

-- the download button on the placeholder objects calls this to directly initiate a download
---@param params table contains url and guid of replacement object
function placeholder_download(params)
  function downloadCoroutine()
    -- show progress bar
    UI.setAttribute('download_progress', 'active', true)

    -- update progress bar
    while requestObj do
      UI.setAttribute('download_progress', 'percentage', requestObj.download_progress * 100)
      coroutine.yield(0)
    end
    UI.setAttribute('download_progress', 'percentage', 100)

    -- wait 30 frames
    for i = 1, 30 do
      coroutine.yield(0)
    end

    -- hide progress bar
    UI.setAttribute('download_progress', 'active', false)

    -- hide download window
    if params.player then
      changeWindowVisibilityForColor(params.player.color, "downloadWindow", false)
    end
    return 1
  end

  local url = SOURCE_REPO .. params.filename .. ".json"
  requestObj = WebRequest.get(url, function(request) contentDownloadCallback(request, params) end)
  startLuaCoroutine(Global, 'downloadCoroutine')
end

-- spawns a bag that contains every object from the library
function onClick_downloadAll(player)
  broadcastToAll("Download initiated - this will take a few minutes!")

  -- hide download window
  changeWindowVisibilityForColor(player.color, "downloadWindow", false)

  startLuaCoroutine(Global, "coroutineDownloadAll")
end

function coroutineDownloadAll()
  local JSON = [[
    {
      "Name": "Bag",
      "Transform": {
        "posX": {{POSX}},
        "posY": 2,
        "posZ": -95,
        "rotX": 0,
        "rotY": 270,
        "rotZ": 0,
        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1
      },
      "Nickname": "{{NICKNAME}}",
      "Bag": {
        "Order": 0
      },
      "ContainedObjects": [
  ]]

  local posx = -45.0
  local downloadedItems = 0
  local skippedItems = 0

  -- loop through the library to add content
  for contentType, objectList in pairs(library) do
    broadcastToAll("Downloading " .. contentType .. "...")
    local contained = ""
    for _, params in ipairs(objectList) do
      local request = WebRequest.get(SOURCE_REPO .. params.filename .. ".json", function() end)
      local start = os.time()
      while true do
        if request.is_done then
          contained = contained .. request.text .. ","
          downloadedItems = downloadedItems + 1
          break
          -- time-out if item can't be loaded in 5s
        elseif request.is_error or (os.time() - start) > 5 then
          skippedItems = skippedItems + 1
          break
        end
        coroutine.yield(0)
      end
    end
    local JSONCopy = JSON
    JSONCopy = JSONCopy .. contained .. "]}"
    JSONCopy = JSONCopy:gsub("{{POSX}}", posx)
    JSONCopy = JSONCopy:gsub("{{NICKNAME}}", contentType)
    spawnObjectJSON({ json = JSONCopy })
    posx = posx + 3
  end

  broadcastToAll(downloadedItems .. " objects downloaded.", "Green")
  broadcastToAll(skippedItems .. " objects had a time-out / error.", "Orange")
  return 1
end

-- spawns a placeholder box for the selected object
function onClick_spawnPlaceholder(player)
  -- get object references
  local item = library[contentToShow][currentListItem]
  local dummy = guidReferenceApi.getObjectByOwnerAndType("Mythos", "PlaceholderBoxDummy")

  -- error handling
  if not item.boxsize or item.boxsize == "" or not item.boxart or item.boxart == "" then
    print("Error loading object.")
    return
  end

  -- get data for placeholder
  local spawnPos = { -39.5, 2, -87 }

  local meshTable = {
    big = "https://raw.githubusercontent.com/RobMayer/TTSLibrary/master/advboxes/core_h_MSH.obj",
    small = "https://raw.githubusercontent.com/RobMayer/TTSLibrary/master/advboxes/tuckbox_h_MSH.obj",
    wide = "https://steamusercontent-a.akamaihd.net/ugc/2278324073260846176/33EFCAF30567F8756F665BE5A2A6502E9C61C7F7/"
  }

  local scaleTable = {
    big = { 1.00, 0.14, 1.00 },
    small = { 2.21, 0.46, 2.42 },
    wide = { 2.00, 0.11, 1.69 }
  }

  local placeholder = spawnObject({
    type = "Custom_Model",
    position = spawnPos,
    rotation = { 0, 270, 0 },
    scale = scaleTable[item.boxsize],
  })

  placeholder.setCustomObject({
    mesh = meshTable[item.boxsize],
    diffuse = item.boxart,
    material = 3
  })

  if item.boxsize == "big" then
    placeholder.addTag("LargeBox")
  end

  placeholder.setColorTint({ 1, 1, 1, 71 / 255 })
  placeholder.setName(item.name)
  placeholder.setDescription("by " .. (item.author or "Unknown"))
  placeholder.setGMNotes(item.filename)
  placeholder.setLuaScript(dummy.getLuaScript())
  Player.getPlayers()[1].pingTable(spawnPos)

  -- hide download window
  changeWindowVisibilityForColor(player.color, "downloadWindow", false)
end

-- toggles the visibility of the respective UI
---@param player tts__Player Player that triggered this
---@param windowId string Name of the UI to toggle
function onClick_toggleUi(player, windowId)
  -- let the Navigation Overlay handle the toggling of its visibility modes
  if windowId == "Navigation Overlay" then
    navigationOverlayApi.cycleVisibility(player.color)
    return
  end

  -- hide the playAreaGallery / downloadWindow if visible
  if windowId == "downloadWindow" then
    changeWindowVisibilityForColor(player.color, "playAreaGallery", false)
  elseif windowId == "playAreaGallery" then
    changeWindowVisibilityForColor(player.color, "downloadWindow", false)
  elseif windowId == "blessCurseManager" then
    -- store the state of the Bless/Curse Manager UI to restore it onLoad()
    blurseVisibility[player.color] = changeWindowVisibilityForColor(player.color, "blessCurseManager")
    return
  end

  changeWindowVisibilityForColor(player.color, windowId)
end

-- wrapper for the real function to unpack arguments
function changeWindowVisibilityForColorWrapper(params)
  changeWindowVisibilityForColor(params.color, params.windowId, params.overrideState, params.owner)
end

-- toggles the visibility of the specific window for the specified color
---@param color string Player color to toggle the visibility for
---@param windowId string ID of the XML element
---@param overrideState? boolean Forcefully sets the new visibility
---@param owner? tts__Object Object that owns the XML (or nil if Global)
---@return boolean visible Returns the new state of the visibility
function changeWindowVisibilityForColor(color, windowId, overrideState, owner)
  local targetUi = UI
  if owner then
    targetUi = owner.UI
  end

  -- current state
  local colorString = targetUi.getAttribute(windowId, "visibility") or ""

  -- parse the visibility string
  local visible = false
  local viewers = {}
  for str in string.gmatch(colorString, "%a+") do
    table.insert(viewers, str)
    if str == color then
      visible = true
    end
  end

  -- add / remove the color as viewer
  if visible == true then
    removeValueFromTable(viewers, color)
  elseif visible == false then
    table.insert(viewers, color)
  end
  visible = not visible

  -- resolve override
  if overrideState == true and visible == false then
    table.insert(viewers, color)
    visible = true
  elseif overrideState == false and visible == true then
    removeValueFromTable(viewers, color)
    visible = false
  end

  -- construct new string
  local newColorString = ""
  for _, viewer in ipairs(viewers) do
    newColorString = newColorString .. viewer .. "|"
  end

  -- remove last delimiter
  newColorString = newColorString:sub(1, -2)

  -- update the visibility of the XML
  targetUi.setAttribute(windowId, "visibility", newColorString)
  targetUi.setAttribute(windowId, "active", newColorString ~= "")

  return visible
end

-- updates the preview window
function updatePreviewWindow()
  local item = library[contentToShow][currentListItem]
  local tempImage =
  "https://steamusercontent-a.akamaihd.net/ugc/2115061845788345842/2CD6ABC551555CCF58F9D0DDB7620197BA398B06/"

  -- set default image if not defined
  if item.boxsize == nil or item.boxsize == "" or item.boxart == nil or item.boxart == "" then
    item.boxsize = "big"
    item.boxart =
    "https://steamusercontent-a.akamaihd.net/ugc/762723517667628371/18438B0A0045038A7099648AA3346DFCAA267C66/"
  end

  UI.setValue("previewTitle", item.name)
  UI.setValue("previewAuthor", "by " .. (item.author or "- Author not found -"))
  UI.setValue("previewDescription", item.description or "- Description not found -")

  -- update mask according to size (hardcoded values to align image in mask)
  local maskData = {}
  if item.boxsize == "big" then
    maskData = {
      image = "box-cover-mask-big",
      width = "870",
      height = "435",
      offsetXY = "154 60"
    }
  elseif item.boxsize == "small" then
    maskData = {
      image = "box-cover-mask-small",
      width = "792",
      height = "594",
      offsetXY = "135 13"
    }
  elseif item.boxsize == "wide" then
    maskData = {
      image = "box-cover-mask-wide",
      width = "756",
      height = "630",
      offsetXY = "-190 -70"
    }
  end

  -- loading empty image as placeholder until real image is loaded
  UI.setAttribute("previewArtImage", "image", tempImage)

  -- insert the image itself
  UI.setAttribute("previewArtImage", "image", item.boxart)
  UI.setAttributes("previewArtMask", maskData)
end

-- formats the json response from the webrequest into a key-value lua table
function formatLibrary(jsonResponse)
  library = {}

  for _, item in ipairs(jsonResponse["content"]) do
    local contentType = item["type"]

    -- add "fanmade" for unofficial content
    if item["author"] ~= "Fantasy Flight Games" then
      contentType = "fanmade-" .. contentType
    end

    -- initialize subtable
    if library[contentType] == nil then
      library[contentType] = {}
    end
    table.insert(library[contentType], item)
  end
end

-- updates the window content to the requested content
---@param skipAuthorUpdate? boolean If true, skips the update for the author dropdown
function updateDownloadItemList(skipAuthorUpdate)
  if not library then return end

  -- addition of list items according to library file
  local globalXml = UI.getXmlTable()
  local contentList = getXmlTableElementById(globalXml, 'contentList')

  -- reset the list of authors unless skipping
  if not skipAuthorUpdate then
    authorList = {}
  end

  contentList.children = {}
  for i, v in ipairs(library[contentToShow]) do
    -- if there's a filter, apply it (both for name and author)
    if (searchFilter == nil or string.contains(string.lower(v.name), searchFilter)) and
        (authorFilter == nil or v.author == authorFilter) then

      -- start collecting authors unless skipping
      if not skipAuthorUpdate then
        table.insert(authorList, v.author)
      end

      table.insert(contentList.children,
        {
          tag = "Panel",
          attributes = { id = "panel" .. i },
          children = {
            tag = 'Text',
            value = v.name,
            attributes = {
              id = contentToShow .. "_" .. i,
              onClick = 'onClick_select',
              alignment = 'MiddleLeft'
            }
          }
        })
    end
  end

  contentList.attributes.height = #contentList.children * 27

  -- populate the author dropdown with options unless skipping
  if not skipAuthorUpdate then
    authorList = removeDuplicatesAndSort(authorList)

    local authorDropdown = getXmlTableElementById(globalXml, 'authorDropdown')
    authorDropdown.children = { { tag = "Option", value = "All authors" } }
    for _, author in ipairs(authorList) do
      table.insert(authorDropdown.children, { tag = "Option", value = author })
    end
  end

  updateGlobalXml(globalXml)

  -- select the first item
  Wait.time(onClick_select, 0.2)
end

-- this helper function updates the global XML while preserving the visibility of windows
function updateGlobalXml(newXml)
  -- preserve visibility settings for these elements
  local windowIdList = {
    "playAreaGallery",
    "downloadWindow",
    "optionPanel"
  }

  -- get current state and update newXml
  for _, windowId in ipairs(windowIdList) do
    local element = getXmlTableElementById(newXml, windowId)
    element.attributes.active = UI.getAttribute(windowId, "active")
    element.attributes.visibility = UI.getAttribute(windowId, "visibility")
  end

  UI.setXmlTable(newXml)
end

-- called after the webrequest of downloading an item
-- deletes the placeholder and spawns the downloaded item
function contentDownloadCallback(request, params)
  requestObj = nil

  -- error handling
  if request.is_error or request.response_code ~= 200 then
    print('Error: ' .. request.error)
    return
  end

  -- initiate content spawning
  local spawnTable = { json = request.text }
  if params.replace then
    local replacedObject = getObjectFromGUID(params.replace)
    if replacedObject then
      spawnTable.position = replacedObject.getPosition()
      spawnTable.rotation = replacedObject.getRotation()
      spawnTable.scale    = replacedObject.getScale()
      destroyObject(replacedObject)
    end
  end

  -- if position is undefined, get empty position
  if not spawnTable.position then
    local pos = getValidSpawnPosition()
    if not pos then
      broadcastToAll("Please make sure there's space in the upper middle of the table and try again.", "Red")
      return
    end

    spawnTable.position = pos
    spawnTable.rotation = { 0, 270, 0 }
  else
  end

  -- if spawned from menu, move the camera and/or ping the table
  if params.name then
    spawnTable["callback_function"] = function(obj)
      Wait.time(function()
        -- move camera
        if params.player then
          params.player.lookAt({
            position = obj.getPosition(),
            pitch    = 65,
            yaw      = 90,
            distance = 65
          })
        end

        -- ping object
        local pingPlayer = params.player or Player.getPlayers()[1]
        pingPlayer.pingTable(obj.getPosition())
      end, 0.1)
    end
  end

  if pcall(function() spawnObjectJSON(spawnTable) end) then
    print('Object loaded.')
  else
    print('Error loading object.')
  end
end

-- gets the first empty position to spawn a custom content object safely
function getValidSpawnPosition()
  local potentialSpawnPositionX = { 65, 50, 35 }
  local potentialSpawnPositionY = 1.5
  local potentialSpawnPositionZ = { 35, 21, 7, -7, -21, -35 }

  for _, posX in ipairs(potentialSpawnPositionX) do
    for _, posZ in ipairs(potentialSpawnPositionZ) do
      local pos = Vector(posX, potentialSpawnPositionY, posZ)
      if checkPositionForContentSpawn(pos) then
        return pos
      end
    end
  end
  return nil
end

-- checks whether something is in the specified position
-- first hit is the table surface, additional hits means something is there
---@return boolean: True if empty
function checkPositionForContentSpawn(checkPos)
  local searchResult = searchLib.atPosition(checkPos)
  return #searchResult == 1
end

-- downloading of the library file
function libraryDownloadCallback(request)
  if request.is_error or request.response_code ~= 200 then
    print('error: ' .. request.error)
    return
  end

  local jsonResponse = nil
  if pcall(function() jsonResponse = JSON.decode(request.text) end) then
    formatLibrary(jsonResponse)
    updateDownloadItemList()
  else
    print('error parsing downloaded library')
  end
end

-- loops through an XML table and returns the specified object
---@param ui table XmlTable (get this via getXmlTable)
---@param id string Id of the object to return
function getXmlTableElementById(ui, id)
  for _, obj in ipairs(ui) do
    if obj.attributes and obj.attributes.id and obj.attributes.id == id then return obj end
    if obj.children then
      local result = getXmlTableElementById(obj.children, id)
      if result then return result end
    end
  end
  return nil
end

---------------------------------------------------------
-- Option Panel related functionality
---------------------------------------------------------

-- changes the UI state and the internal variable for the togglebuttons
function onClick_toggleOption(_, _, id)
  local currentState = optionPanel[id]
  local newState = not currentState
  applyOptionPanelChange(id, newState)
  UI.setAttribute(id, "image", newState and "option_on" or "option_off")
end

-- color selection for playArea
function onClick_playAreaConnectionColor(player, _, id)
  player.showColorDialog(optionPanel[id], function(color)
    applyOptionPanelChange(id, color)
  end)
end

-- called by the language selection dropdown
function languageSelected(_, selectedIndex, id)
  optionPanel[id] = LANGUAGES[tonumber(selectedIndex) + 1].code
end

-- returns the ID (position in the table) for a provided language code
function returnLanguageId(code)
  for index, tbl in ipairs(LANGUAGES) do
    if tbl.code == code then
      return index
    end
  end
end

-- called by the resource counter selection dropdown
function resourceCounterSelected(_, selectedIndex, id)
  optionPanel[id] = RESOURCE_OPTIONS[tonumber(selectedIndex) + 1]
end

-- returns the ID for the provided option name
function returnResourceCounterId(name)
  for index, optionName in ipairs(RESOURCE_OPTIONS) do
    if optionName == name then
      return index
    end
  end
end

-- called by the playermat removal selection dropdown
function playermatRemovalSelected(player, selectedIndex, id)
  if selectedIndex == "0" then return end

  local matColorList = { "White", "Orange", "Green", "Red" }
  local matColor = matColorList[tonumber(selectedIndex)]
  local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")

  if mat then
    -- confirmation dialog about deletion
    player.pingTable(mat.getPosition())
    player.showConfirmDialog(
      "Do you really want to remove " .. matColor .. "'s playermat and related objects? This can't be reversed.",
      function()
        removePlayermat(matColor)
      end)
  else
    -- info dialog that it is already deleted
    player.showInfoDialog(matColor .. "'s playermat has already been removed.")
  end

  -- set selected value back to first option
  UI.setAttribute(id, "value", 0)
end

-- removes a playermat and all related objects from play
---@param matColor string Color of the playermat to remove
function removePlayermat(matColor)
  -- if there's a seated player, move them to grey
  local handColor = playermatApi.getPlayerColor(matColor)
  if Player[handColor].seated then
    Player[handColor].changeColor("Grey")
  end

  local matObjects = guidReferenceApi.getObjectsByOwner(matColor)
  if not matObjects.Playermat then return end

  -- remove action tokens
  local actionTokens = playermatApi.searchAroundPlayermat(matColor, "isUniversalToken")
  for _, obj in ipairs(actionTokens) do
    obj.destruct()
  end

  -- remove mat owned objects
  for _, obj in pairs(matObjects) do
    obj.destruct()
  end
end

-- sets the option panel to the correct state (corresponding to 'optionPanel')
function updateOptionPanelState()
  for id, optionValue in pairs(optionPanel) do
    if id == "cardLanguage" and type(optionValue) == "string" then
      local dropdownId = returnLanguageId(optionValue) - 1
      UI.setAttribute(id, "value", dropdownId)
    elseif id == "useResourceCounters" and type(optionValue) == "string" then
      local dropdownId = returnResourceCounterId(optionValue) - 1
      UI.setAttribute(id, "value", dropdownId)
    elseif id == "playAreaConnectionColor" then
      UI.setAttribute(id, "color", "#" .. Color.new(optionValue):toHex())
    elseif (type(optionValue) == "boolean" and optionValue)
        or (type(optionValue) == "string" and optionValue)
        or (type(optionValue) == "table" and #optionValue ~= 0) then
      UI.setAttribute(id, "image", "option_on")
    else
      UI.setAttribute(id, "image", "option_off")
    end
  end
end

-- handles the applying of option selections and calls the respective functions based on the id
---@param id string ID of the option that was selected or deselected
---@param state boolean|any State of the option (true = enabled)
function applyOptionPanelChange(id, state)
  optionPanel[id] = state

  -- option: Snap tags
  if id == "useSnapTags" then
    playermatApi.setLimitSnapsByType(state, "All")

    -- option: Draw 1 button
  elseif id == "showDrawButton" then
    playermatApi.showDrawButton(state, "All")

    -- option: Use class texture
  elseif id == "useClassTexture" then
    playermatApi.useClassTexture(state, "All")

    -- option: Clickable clue counters
  elseif id == "useClueClickers" then
    playermatApi.clickableClues(state, "All")

    -- update master clue counter
    local counter = guidReferenceApi.getObjectByOwnerAndType("Mythos", "MasterClueCounter")
    counter.setVar("useClickableCounters", state)

    -- option: Enable card helpers
  elseif id == "enableCardHelpers" then
    toggleCardHelpers(state)

    -- option: Play area connection drawing
  elseif id == "playAreaConnections" then
    playAreaApi.setConnectionDrawState(state)

    -- option: Play area connection color
  elseif id == "playAreaConnectionColor" then
    playAreaApi.setConnectionColor(state)
    UI.setAttribute(id, "color", "#" .. Color.new(state):toHex())

    -- option: Play area snap tags
  elseif id == "playAreaSnapTags" then
    playAreaApi.setLimitSnapsByType(state)

    -- option: Show clean up helper
  elseif id == "showCleanUpHelper" then
    spawnOrRemoveHelper(state, "Clean Up Helper", { -66, 1.53, 46 })

    -- option: Show hand helper for each player
  elseif id == "showHandHelper" then
    spawnOrRemoveHelperForPlayermats("Hand Helper", state)

    -- option: Show search assistant for each player
  elseif id == "showSearchAssistant" then
    spawnOrRemoveHelperForPlayermats("Search Assistant", state)

    -- option: Show attachment helper
  elseif id == "showAttachmentHelper" then
    spawnOrRemoveHelper(state, "Attachment Helper", { -62, 1.4, 0 })

    -- option: Show CYOA campaign guides
  elseif id == "showCYOA" then
    spawnOrRemoveHelper(state, "CYOA Campaign Guides", { 39, 1.3, -20 })

    -- option: Show displacement tool
  elseif id == "showDisplacementTool" then
    spawnOrRemoveHelper(state, "Displacement Tool", { -57, 1.53, 46 })
  end
end

-- spawns or removes a helper object for all playermats
---@param helperName string Name of the helper object
---@param state boolean Contains the state of the option: true = spawn it, false = remove it
function spawnOrRemoveHelperForPlayermats(helperName, state)
  for color, data in pairs(playermatApi.getHelperSpawnData("All", helperName)) do
    spawnOrRemoveHelper(state, helperName, data.position, data.rotation, color)
  end
end

-- handler for spawn / remove functions of helper objects
---@param state boolean Contains the state of the option: true = spawn it, false = remove it
---@param name string Name of the helper object
---@param position tts__Vector Position of the object (where it will spawn)
---@param rotation? tts__Vector Rotation of the object for spawning (default: {0, 270, 0})
---@param owner? string Owner of the object (defaults to "Mythos")
---@return string|nil GUID GUID of the spawnedObj (or nil if object was removed)
function spawnOrRemoveHelper(state, name, position, rotation, owner)
  if state then
    Player.getPlayers()[1].pingTable(position)
    local spawnedGUID = spawnHelperObject(name, position, rotation).getGUID()
    local cleanName = name:gsub("%s+", "")
    guidReferenceApi.editIndex(owner or "Mythos", cleanName, spawnedGUID)
  else
    removeHelperObject(name)
  end
end

-- copies the specified tool (by name) from the option panel source bag
---@param name string Name of the object that should be copied
---@param position tts__Vector Desired position of the object
---@param rotation? tts__Vector Desired rotation of the object (defaults to object's rotation)
function spawnHelperObject(name, position, rotation)
  local sourceBag = guidReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")

  -- error handling for missing sourceBag
  if not sourceBag then
    broadcastToAll("Option panel source bag could not be found!", "Red")
    return
  end

  local spawnTable = { position = position }

  -- only overrride rotation if there is one provided (object's rotation used instead)
  if rotation then
    spawnTable.rotation = rotation
  end

  for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
    if objData["Nickname"] == name then
      objData["Locked"] = true
      spawnTable.data = objData
      return spawnObjectData(spawnTable)
    end
  end
end

-- removes the specified tool (by name)
---@param name string Object that should be removed
function removeHelperObject(name)
  local cleanName = name:gsub("%s+", "")
  for _, obj in pairs(guidReferenceApi.getObjectsByType(cleanName)) do
    obj.destruct()
  end
end

-- loads saved options
---@param newOptions table Contains the new state for the option panel
function loadSettings(newOptions)
  for id, state in pairs(newOptions) do
    if optionPanel[id] ~= state then
      optionPanel[id] = state
      applyOptionPanelChange(id, state)
    end
  end

  -- update XML UI state
  updateOptionPanelState()
end

-- loads the default options
function onClick_defaultSettings()
  -- clean reset of variables
  optionPanel = {
    cardLanguage = "en",
    changePlayAreaImage = false,
    enableCardHelpers = true,
    playAreaConnectionColor = { a = 1, b = 0.4, g = 0.4, r = 0.4 },
    playAreaConnections = true,
    playAreaSnapTags = true,
    showAttachmentHelper = false,
    showCleanUpHelper = false,
    showCYOA = false,
    showDisplacementTool = false,
    showDrawButton = false,
    showHandHelper = false,
    showSearchAssistant = false,
    showTitleSplash = true,
    useClassTexture = true,
    useClueClickers = false,
    useResourceCounters = "disabled",
    useSnapTags = true
  }

  -- applying changes
  for id, state in pairs(optionPanel) do
    applyOptionPanelChange(id, state)
  end

  -- update UI
  updateOptionPanelState()
end

-- splash scenario title on setup
function titleSplash(scenarioName)
  if optionPanel['showTitleSplash'] then
    -- if there's any ongoing title being displayed, hide it and cancel the waiting function
    if hideTitleSplashWaitFunctionId then
      Wait.stop(hideTitleSplashWaitFunctionId)
      hideTitleSplashWaitFunctionId = nil
      UI.setAttribute('title_splash', 'active', false)
    end

    -- display scenario name and set a 4 seconds (2 seconds animation and 2 seconds on screen)
    -- wait timer to hide the scenario name
    UI.setValue('title_splash_text', scenarioName)
    UI.show('title_splash')
    hideTitleSplashWaitFunctionId = Wait.time(function()
      UI.hide('title_splash')
      hideTitleSplashWaitFunctionId = nil
    end, 4)

    soundCubeApi.playSoundByName("Deep Bell")
  end
end

-- instructs all card helpers to update their visibility
function toggleCardHelpers(state)
  for _, obj in ipairs(getObjectsWithTag("CardWithHelper")) do
    obj.call("setHelperState", state)
  end
end

-- toggles the hand visibility of a hand for a specific player
function handVisibilityToggle(params)
  local playerColor = params.playerColor
  local handColor = params.handColor

  -- collect data for message
  local state, preposition

  -- modify data table
  if not handVisibility[handColor] then
    handVisibility[handColor] = { playerColor, handColor }
    state, preposition = "Showing", "to"
  elseif removeValueFromTable(handVisibility[handColor], playerColor) then
    -- something was removed, maybe clear the table
    if #handVisibility[handColor] == 1 and handVisibility[handColor][1] == handColor then
      handVisibility[handColor] = nil
    end
    state, preposition = "Hiding", "from"
  else
    -- add the new color as viewer
    table.insert(handVisibility[handColor], playerColor)
    state, preposition = "Showing", "to"
  end

  local sourceName = getColoredName(handColor)
  local targetName = getColoredName(playerColor)
  broadcastToAll(state .. " " .. sourceName .. "'s hand " .. preposition .. " " .. targetName .. ".")
  updateHandVisibility()
end

function updateHandVisibility()
  -- update the global setting
  if not next(handVisibility) then
    Hands.hiding = 1
  else
    Hands.hiding = 3
  end

  -- update visibility of cards already in hands (delay seems to be necessary)
  Wait.frames(function()
    for _, handColor in ipairs(Player.getAvailableColors()) do
      for _, handObj in ipairs(Player[handColor].getHandObjects()) do
        applyHidingToCard(handObj, handColor)
      end
    end
  end, 1)
end

-- maybe hide card from non-allowed players
---@param card tts__Object Card to maybe hide
---@param handColor? string Color of the hand this card is in
function applyHidingToCard(card, handColor)
  if next(handVisibility) then
    local viewers = { handColor }
    if handColor and handVisibility[handColor] then
      viewers = handVisibility[handColor]
    end

    local hiddenFrom = Player.getColors()
    for _, viewer in ipairs(viewers) do
      removeValueFromTable(hiddenFrom, viewer)
    end
    card.setHiddenFrom(hiddenFrom)
  else
    card.setHiddenFrom({})
  end
end

-- loads the visibility of the Bless/Curse Manager XML from the internal variable
function updateBlurseVisibility()
  local count = 1
  for playerColor, state in pairs(blurseVisibility) do
    Wait.frames(function() changeWindowVisibilityForColor(playerColor, "blessCurseManager", state) end, count)
    count = count + 3
  end
end

---------------------------------------------------------
-- Update notification related functionality
---------------------------------------------------------

-- grabs the latest mod version and release notes from GitHub (called onLoad())
function getModVersion()
  WebRequest.get(SOURCE_REPO .. 'modversion.json', compareVersion)
end

-- compares the modversion with GitHub and possibly shows the update notification
function compareVersion(request)
  if request.is_error then
    log(request.error)
    return
  end

  -- global variable to make it accessible for other functions
  modMeta = JSON.decode(request.text)

  -- maybe update SOURCE_REPO to specific version
  if modMeta["setSpecificDownloadVersion"] then
    local versionTable = modMeta["setSpecificDownloadVersion"][1]
    if versionTable[MOD_VERSION] then
      SOURCE_REPO = "https://github.com/Chr1Z93/SCED-downloads/releases/download/" .. versionTable[MOD_VERSION] .. "/"
      log("Using download repo version: " .. versionTable[MOD_VERSION])
    end
  end

  -- stop here if on latest or newer version
  if convertVersionToNumber(MOD_VERSION) >= convertVersionToNumber(modMeta["latestVersion"]) then return end

  -- stop here if "don't show again" was clicked for this version before
  if acknowledgedUpgradeVersions[modMeta["latestVersion"]] then return end

  updateNotificationLoading()

  -- delay to avoid lagging during onLoad()
  Wait.time(function() UI.show("FinnIcon") end, 1)
end

-- converts a version number to a string
---@param version string Version number, separated by dots (e.g. 3.3.1)
function convertVersionToNumber(version)
  local major, minor, patch = string.match(version, "(%d+)%.(%d+)%.(%d+)")
  return major * 100 + minor * 10 + patch
end

-- updates the XML update notification based on the mod metadata
function updateNotificationLoading()
  -- grab data
  local highlights = modMeta["releaseHighlights"]

  -- concatenate the release highlights
  local highlightText = "• " .. highlights[1]
  for i, entry in pairs(highlights) do
    if i ~= 1 then
      highlightText = highlightText .. "\n• " .. entry
    end
  end

  -- update the XML UI
  UI.setValue("notificationHeader", "New version available: " .. modMeta["latestVersion"])
  UI.setValue("releaseHighlightText", highlightText)
  UI.setAttribute("highlightRow", "preferredHeight", 20 * #highlights)
  UI.setAttribute("updateNotification", "height", 20 * #highlights + 125)
end

-- close / don't show again buttons on the update notification
function onClick_notification(_, parameter)
  if parameter == "dontShowAgain" then
    -- this variable tracks if "don't show again" was pressed for a version
    acknowledgedUpgradeVersions[modMeta["latestVersion"]] = true
  end
  UI.hide("FinnIcon")
  UI.hide("updateNotification")
end

---------------------------------------------------------
-- Token Manager
---------------------------------------------------------

function TokenManager.initialiize()
  TokenManager.generateOffsets(12)
end

-- Generates the offsets for tokens on a card (clues on locations are different and have their own function)
---@param maxTokens number Maximum amount of tokens on a card
function TokenManager.generateOffsets(maxTokens)
  tokenOffsets = {
    [1] = { Vector(0, 3, -0.2) },
    [2] = { Vector(0.4, 3, -0.2), Vector(-0.4, 3, -0.2) },
    [3] = { Vector(0, 3, -0.9), Vector(0.4, 3, -0.2), Vector(-0.4, 3, -0.2) },
    [4] = { Vector(0.4, 3, -0.9), Vector(-0.4, 3, -0.9), Vector(0.4, 3, -0.2), Vector(-0.4, 3, -0.2) }
  }

  -- generate offsets for numTokens > 4 dynamically
  for numTokens = 5, maxTokens do
    local offsets = {}
    local rows = math.min(4, math.ceil(numTokens / 3))
    local tokensPlaced = 0
    for row = 1, rows do
      local y = 3
      local z = -0.9 + (row - 1) * 0.7
      local tokensInRow = math.min(3, numTokens - tokensPlaced)
      for col = 1, tokensInRow do
        local x = 0
        if tokensInRow == 2 then
          x = col == 1 and -0.4 or 0.4
        elseif tokensInRow == 3 then
          x = (col - 2) * 0.7
        end
        table.insert(offsets, Vector(x, y, z))
        tokensPlaced = tokensPlaced + 1
      end
    end
    tokenOffsets[numTokens] = offsets
  end
  return tokenOffsets
end

-- Spawns tokens for the card. This function is built to just throw a card at it and let it do
-- the work once a card has hit an area where it might spawn tokens. It will check to see if
-- the card has already spawned, find appropriate data from either the uses metadata or the Data
-- Helper, and spawn the tokens.
function TokenManager.spawnForCard(params)
  if tokenSpawnTrackerApi.hasSpawnedTokens(params.card.getGUID()) then return end
  local metadata = JSON.decode(params.card.getGMNotes())
  if metadata ~= nil then
    TokenManager.spawnTokensFromUses(params.card, params.extraUses)
  else
    TokenManager.spawnTokensFromDataHelper(params.card)
  end
end

-- Spawns a set of tokens on the given card.
function TokenManager.spawnTokenGroup(params)
  local card = params.card
  local tokenType = params.tokenType
  local tokenCount = params.tokenCount
  local shiftDown = params.shiftDown
  local subType = params.subType
  local temporary = params.temporary

  if tokenType == "damage" or tokenType == "horror" then
    TokenManager.spawnCounterToken(card, tokenType, tokenCount, shiftDown)
  elseif tokenType == "resource" and optionPanel["useResourceCounters"] == "enabled" then
    TokenManager.spawnResourceCounterToken(card, tokenCount)
  elseif tokenType == "resource" and optionPanel["useResourceCounters"] == "custom" and tokenCount == 0 then
    TokenManager.spawnResourceCounterToken(card, tokenCount)
  else
    TokenManager.spawnMultipleTokens(card, tokenType, tokenCount, shiftDown, subType, temporary)
  end
end

-- Spawns a single counter token and sets the value to tokenValue. Used for damage and horror tokens.
---@param card tts__Object Card to spawn tokens on
---@param tokenType string Type of token to spawn (template needs to be in source bag)
---@param tokenValue number Value to set the damage/horror to
function TokenManager.spawnCounterToken(card, tokenType, tokenValue, shiftDown)
  TokenManager.spawnToken({
    position = card.positionToWorld(tokenOffsets[1][1] + Vector(0, 0, shiftDown)),
    tokenType = tokenType,
    rotation = card.getRotation(),
    scriptstate = tokenValue
  })
end

function TokenManager.spawnResourceCounterToken(card, tokenValue)
  TokenManager.spawnToken({
    position = card.positionToWorld(card.positionToLocal(card.getPosition()) + Vector(0, 0.2, -0.5)),
    tokenType = "resourceCounter",
    rotation = card.getRotation(),
    scriptstate = tokenValue
  })
end

-- Spawns a number of tokens.
---@param tokenType string Type of token to spawn (template needs to be in source bag)
---@param tokenCount number How many tokens to spawn
---@param shiftDown? number An offset for the z-value of this group of tokens
---@param subType? string Subtype of token to spawn. This will only differ from the tokenName for resource or action tokens
---@param temporary? boolean If present adds the temporary tag to an action token
function TokenManager.spawnMultipleTokens(card, tokenType, tokenCount, shiftDown, subType, temporary)
  if tokenCount < 1 then return end

  local offsets = {}
  if tokenType == "clue" then
    offsets = TokenManager.buildClueOffsets(card, tokenCount)
  else
    if tokenCount > 12 then
      printToAll("Attempting to spawn " .. tokenCount .. " tokens. Spawning clickable counter instead.")
      TokenManager.spawnResourceCounterToken(card, tokenCount)
      return
    end
    for i = 1, tokenCount do
      offsets[i] = card.positionToWorld(tokenOffsets[tokenCount][i])
    end
  end

  if shiftDown ~= nil then
    -- Copy the offsets to make sure we don't change the static values
    local baseOffsets = offsets
    offsets = {}

    -- get a vector for the shifting (downwards local to the card)
    local shiftDownVector = Vector(0, 0, shiftDown):rotateOver("y", card.getRotation().y)
    for i, baseOffset in ipairs(baseOffsets) do
      offsets[i] = baseOffset + shiftDownVector
    end
  end

  if offsets == nil then
    error("couldn't find offsets for " .. tokenCount .. ' tokens')
    return
  end

  -- this is used to load the correct state for additional resource tokens (e.g. "Ammo")
  local callbackName = nil
  local callbackParams = nil
  local stateID = stateTable[string.lower(subType or "")]
  if tokenType == "resource" then
    callbackName = "updateStateToken"
    callbackParams = stateID
  elseif tokenType == "universalActionAbility" then
    local matColor = playermatApi.getMatColorByPosition(card.getPosition())
    local activeInvestigatorData = playermatApi.getActiveInvestigatorData(matColor)
    callbackName = "updateUniversalActionAbilityToken"
    callbackParams = { class = activeInvestigatorData.class, symbol = subType or activeInvestigatorData.class }

    if temporary then
      callbackParams.addTag = "Temporary"
    end
  end

  for i = 1, tokenCount do
    TokenManager.spawnToken({
      position = offsets[i],
      tokenType = tokenType,
      rotation = card.getRotation(),
      callbackName = callbackName,
      callbackParams = callbackParams
    })
  end
end

-- Spawns a single token at the given global position by copying it from the template bag.
function TokenManager.spawnToken(params)
  local position = params.position
  local rotation = params.rotation
  local tokenType = params.tokenType
  local callbackName = params.callbackName
  local callbackParams = params.callbackParams
  local scriptstate = params.scriptstate

  -- initialize data table
  local spawnData = { position = position }

  -- maybe set callback function
  if callbackName then
    if type(_G[callbackName]) ~= "function" then
      error("Callback function " .. callbackName .. " does not exist")
      return
    else
      spawnData.callback_function = function(obj) _G[callbackName](obj, callbackParams) end
    end
  end

  -- get data for token type
  local loadTokenType = tokenType
  if tokenType == "clue" or tokenType == "doom" then
    loadTokenType = "clueDoom"
  end

  TokenManager.initTokenTemplates()
  local tokenTemplate = tokenTemplates[loadTokenType]
  if tokenTemplate == nil then
    error("Unknown token type '" .. loadTokenType .. "'")
    return
  end

  tokenTemplate.Nickname = ""
  spawnData.data = tokenTemplate

  -- maybe directly update the script state of the token
  if scriptstate then
    spawnData.data["LuaScriptState"] = tostring(scriptstate)
  end

  -- get rotation for the token
  -- Take ONLY the Y-value for rotation, so we don't flip the token coming out of the bag
  local rot = Vector(tokenTemplate.Transform.rotX, 270, tokenTemplate.Transform.rotZ)
  if rotation ~= nil then
    rot.y = rotation.y
  end
  if tokenType == "doom" then
    rot.z = 180
  end

  spawnData.rotation = rot

  return spawnObjectData(spawnData)
end

-- Checks a card for metadata to maybe replenish it
function TokenManager.maybeReplenishCard(params)
  for _, useInfo in ipairs(params.uses) do
    if useInfo.count and useInfo.replenish then
      TokenManager.replenishTokens(params.card, useInfo)
    end
  end
end

-- Pushes new player card data into the local copy of the Data Helper player data.
---@param dataTable table Key/Value pairs following the DataHelper style
function TokenManager.addPlayerCardData(dataTable)
  TokenManager.initDataHelperData()
  for k, v in pairs(dataTable) do
    playerCardData[k] = v
  end
end

-- Pushes new location data into the local copy of the Data Helper location data.
---@param dataTable table Key/Value pairs following the DataHelper style
function TokenManager.addLocationData(dataTable)
  TokenManager.initDataHelperData()
  for k, v in pairs(dataTable) do
    locationData[k] = v
  end
end

-- Checks to see if the given card has location data in the DataHelper
---@param card tts__Object Card to check for data
---@return boolean: True if this card has data in the helper, false otherwise
function TokenManager.hasLocationData(card)
  TokenManager.initDataHelperData()
  return TokenManager.getLocationData(card) ~= nil
end

function TokenManager.initTokenTemplates()
  if tokenTemplates ~= nil then return end
  tokenTemplates = {}
  local tokenSource = guidReferenceApi.getObjectByOwnerAndType("Mythos", "TokenSource")
  for _, tokenTemplate in ipairs(tokenSource.getData().ContainedObjects) do
    local tokenName = tokenTemplate.Memo
    tokenTemplates[tokenName] = tokenTemplate
  end
end

-- Copies the data from the DataHelper. Will only happen once.
function TokenManager.initDataHelperData()
  if playerCardData ~= nil then return end
  local dataHelper = guidReferenceApi.getObjectByOwnerAndType("Mythos", "DataHelper")
  playerCardData = dataHelper.getTable('PLAYER_CARD_DATA')
  locationData = dataHelper.getTable('LOCATIONS_DATA')
end

-- Spawn tokens for a card based on the uses metadata. This will consider the face up/down state
-- of the card for both locations and standard cards.
---@param card tts__Object Card to maybe spawn tokens for
---@param extraUses table A table of <use type>=<count> which will modify the number of tokens
---    spawned for that type. e.g. Akachi's playermat should pass "Charge"=1
function TokenManager.spawnTokensFromUses(card, extraUses)
  local uses = TokenManager.getUses(card)
  if uses == nil then return end

  -- go through tokens to spawn
  local tokenCount
  for i, useInfo in ipairs(uses) do
    tokenCount = (useInfo.count or 0) + (useInfo.countPerInvestigator or 0) * playAreaApi.getInvestigatorCount()
    if extraUses ~= nil and extraUses[useInfo.type] ~= nil then
      tokenCount = tokenCount + extraUses[useInfo.type]
    end
    -- Shift each spawned group after the first down so they don't pile on each other
    TokenManager.spawnTokenGroup({
      card = card,
      tokenType = useInfo.token,
      tokenCount = tokenCount,
      shiftDown = (i - 1) * 0.8,
      subType = useInfo.type
    })
  end

  tokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
end

-- Spawn tokens for a card based on the data helper data. This will consider the face up/down state
-- of the card for both locations and standard cards.
---@param card tts__Object Card to maybe spawn tokens for
function TokenManager.spawnTokensFromDataHelper(card)
  TokenManager.initDataHelperData()
  local playerData = TokenManager.getPlayerCardData(card)
  if playerData ~= nil then
    TokenManager.spawnPlayerCardTokensFromDataHelper(card, playerData)
  end
  local specificLocationData = TokenManager.getLocationData(card)
  if specificLocationData ~= nil then
    TokenManager.spawnLocationTokensFromDataHelper(card, specificLocationData)
  end
end

-- Spawn tokens for a player card using data retrieved from the Data Helper.
---@param card tts__Object Card to maybe spawn tokens for
---@param playerData table Player card data structure retrieved from the DataHelper. Should be
--     the right data for this card.
function TokenManager.spawnPlayerCardTokensFromDataHelper(card, playerData)
  TokenManager.spawnTokenGroup({
    card = card,
    tokenType = playerData.tokenType,
    tokenCount = playerData.tokenCount
  })
  tokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
end

-- Spawn tokens for a location using data retrieved from the Data Helper.
---@param card tts__Object Card to maybe spawn tokens for
---@param locationData table Location data structure retrieved from the DataHelper. Should be
--     the right data for this card.
function TokenManager.spawnLocationTokensFromDataHelper(card, locationData)
  local clueCount = TokenManager.getClueCountFromData(card, locationData)
  if clueCount > 0 then
    TokenManager.spawnTokenGroup({
      card = card,
      tokenType = "clue",
      tokenCount = clueCount
    })
    tokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
  end
end

function TokenManager.getPlayerCardData(card)
  return playerCardData[card.getName() .. ':' .. card.getDescription()]
      or playerCardData[card.getName()]
end

function TokenManager.getLocationData(card)
  return locationData[card.getName() .. '_' .. card.getGUID()] or locationData[card.getName()]
end

function TokenManager.getClueCountFromData(card, locationData)
  -- Return the number of clues to spawn on this location
  if locationData == nil then
    error('attempted to get clue for unexpected object: ' .. card.getName())
    return 0
  end

  if ((card.is_face_down and locationData.clueSide == 'back')
        or (not card.is_face_down and locationData.clueSide == 'front')) then
    if locationData.type == 'fixed' then
      return locationData.value
    elseif locationData.type == 'perPlayer' then
      return locationData.value * playAreaApi.getInvestigatorCount()
    end
    error('unexpected location type: ' .. locationData.type)
  end
  return 0
end

-- Gets the right uses structure for this card, based on metadata and face up/down state
---@param card tts__Object Card to pull the uses from
TokenManager.getUses = function(card)
  local metadata = JSON.decode(card.getGMNotes()) or {}
  if metadata.type == "Location" then
    if card.is_face_down and metadata.locationBack ~= nil then
      return metadata.locationBack.uses
    elseif not card.is_face_down and metadata.locationFront ~= nil then
      return metadata.locationFront.uses
    end
  elseif not card.is_face_down then
    return metadata.uses
  end
  return nil
end

-- Dynamically create positions for clues on a card
---@param card tts__Object Card the clues will be placed on
---@param count number How many clues?
---@return table: Array of global positions to spawn the clues at
TokenManager.buildClueOffsets = function(card, count)
  -- make sure clues always spawn from left to right
  local modifier = card.is_face_down and 1 or -1

  local cluePositions = {}
  for i = 1, count do
    -- get the set number (1 for clue 1-16, 2 for 17-32 etc.)
    local set = math.floor((i - 1) / 16) + 1

    -- get the local index (always number from 1-16)
    local localIndex = (i - 1) % 16

    -- get row and column for this clue
    local row = math.floor(localIndex / 4) + 1
    local column = localIndex % 4

    -- calculate local position
    local localPos = Vector((-0.825 + 0.55 * column) * modifier, 0, -1.5 + 0.55 * row)

    -- get the global clue position (higher y-position for each set)
    local cluePos = card.positionToWorld(localPos) + Vector(0, 0.03 + 0.103 * (set - 1), 0)

    -- add position to table
    table.insert(cluePositions, cluePos)
  end
  return cluePositions
end

---@param card tts__Object Card object to be replenished
---@param useInfo table The already decoded subtable of metadata.uses (to avoid decoding again)
function TokenManager.replenishTokens(card, useInfo)
  -- get current amount of matching resource tokens on the card
  local clickableResourceCounter = nil
  local foundTokens = 0

  -- we're only searching 80% of the cards area to avoid matching tokens on other cards
  -- (except for clues, since these are on locations and they should never be this close)
  local maybeDeleteThese = {}
  if useInfo.token == "clue" then
    for _, obj in ipairs(searchLib.onObject(card, "isClue")) do
      foundTokens = foundTokens + math.abs(obj.getQuantity())
      table.insert(maybeDeleteThese, obj)
    end
  elseif useInfo.token == "doom" then
    for _, obj in ipairs(searchLib.onObject(card, "isDoom", 0.8)) do
      foundTokens = foundTokens + math.abs(obj.getQuantity())
      table.insert(maybeDeleteThese, obj)
    end
  else
    -- search for the token instead if there's no special resource state for it
    local searchType = string.lower(useInfo.type)
    if stateTable[searchType] == nil then
      searchType = useInfo.token
    end

    for _, obj in ipairs(searchLib.onObject(card, "isTileOrToken", 0.8)) do
      local memo = obj.getMemo()
      if searchType == memo then
        foundTokens = foundTokens + math.abs(obj.getQuantity())
        table.insert(maybeDeleteThese, obj)
      elseif memo == "resourceCounter" then
        foundTokens = obj.getVar("val")
        clickableResourceCounter = obj
        break
      end
    end
  end

  -- this is the theoretical new amount of uses (to be checked below)
  local newCount = foundTokens + useInfo.replenish

  -- if there are already more uses than the replenish amount, keep them
  if foundTokens > useInfo.count then
    newCount = foundTokens
    -- only replenish up until the replenish amount
  elseif newCount > useInfo.count then
    newCount = useInfo.count
  end

  -- update the clickable counter or spawn a group of tokens
  if clickableResourceCounter then
    clickableResourceCounter.call("updateVal", newCount)
  else
    -- delete existing tokens
    for _, obj in ipairs(maybeDeleteThese) do
      obj.destruct()
    end

    -- spawn new token group
    TokenManager.spawnTokenGroup({
      card = card,
      tokenType = useInfo.token,
      tokenCount = newCount,
      subType = useInfo.type
    })
  end
end

-- adds a use to a card
function TokenManager.addUseToCard(params)
  local card = params.card
  local useType = params.useType
  local metadata = JSON.decode(card.getGMNotes()) or {}
  -- get correct data for location
  if metadata.type == "Location" then
    if not card.is_face_down and metadata.locationFront ~= nil then
      metadata = metadata.locationFront
    elseif metadata.locationBack ~= nil then
      metadata = metadata.locationBack
    end

    -- if there are no uses at all, add "empty" uses for fake replenishing (only for clues)
    if metadata.uses == nil then
      metadata.uses = { { token = "clue" } }
    end
  end

  local match = false
  for _, useInfo in ipairs(metadata.uses or {}) do
    if useInfo.token == useType then
      -- artificially create replenish data to re-use that existing functionality
      useInfo.count = 999
      useInfo.replenish = 1
      match = true
    else
      -- artificially disable other uses from replenishing
      useInfo.replenish = nil
    end
  end

  -- if matching uses were found, perform the "fake" replenish
  if match then
    TokenManager.maybeReplenishCard({ card = card, uses = metadata.uses })
    return true
  else
    return false
  end
end

-- generates the data to spawn an infinite bag of a specific type of resources
function TokenManager.getDataForInfiniteBag(params)
  -- re-assign parameters for convenience
  local tokenType = params.tokenType
  local position = params.position
  local rotation = params.rotation

  -- make sure the token templates are initialized
  TokenManager.initTokenTemplates()

  -- create a copy of the resource token (to not modify the source)
  local template = deepCopy(tokenTemplates["resource"])
  local subTypeStateId = stateTable[tokenType]
  local subTypeData = template["States"][subTypeStateId]

  -- add states to data
  subTypeData["States"] = template["States"]

  -- add "1" state and remove the current state
  subTypeData["States"][1] = template
  subTypeData["States"][1]["States"] = nil
  subTypeData["States"][subTypeStateId] = nil

  -- update rotation of the main state
  subTypeData["Transform"].rotX = 0
  subTypeData["Transform"].rotY = 0
  subTypeData["Transform"].rotZ = 0

  -- generate and return data for the infinite bag
  local properTypeName = tokenType:gsub("^%l", string.upper)
  return {
    Name = "Infinite_Bag",
    Nickname = properTypeName .. " Bag",
    ContainedObjects = { subTypeData },
    Transform = {
      posX = position.x,
      posY = position.y,
      posZ = position.z,
      rotX = rotation.x,
      rotY = rotation.y,
      rotZ = rotation.z,
      scaleX = 1,
      scaleY = 1,
      scaleZ = 1
    }
  }
end

---------------------------------------------------------
-- Callback functions for token spawning
---------------------------------------------------------

function updateUniversalActionAbilityToken(obj, params)
  obj.call("updateClassAndSymbol", params)
  if params.addTag then
    obj.call("addTemporaryStatus")
  end
end

function updateStateToken(obj, stateID)
  if stateID ~= nil and stateID ~= 1 then
    obj.setState(stateID)
  end
end

---------------------------------------------------------
-- Utility functions
---------------------------------------------------------

-- allows calling a function inside of a table (like the TokenManager)
function callTable(params)
  local keys = params[1] or {}
  local arg = params[2] or nil
  local var = _G
  for _, key in ipairs(keys) do
    var = var[key]
    if type(var) ~= "table" then break end
  end
  if type(var) ~= "function" then
    log("resulting var was not a function " .. table.concat(keys, "->"))
    return
  end
  return var(arg)
end

-- removes a value from a table
---@return boolean: True if something was removed
function removeValueFromTable(t, val)
  for i, v in ipairs(t) do
    if v == val then
      table.remove(t, i)
      return true
    end
  end
  return false
end

-- checks if a table is empty
function isTableEmpty(tbl)
  if next(tbl) == nil then
    return true
  else
    return false
  end
end

-- returns the colored steam name or color
---@param playerColor string Color of the player
function getColoredName(playerColor)
  local displayName = playerColor
  if Player[playerColor].steam_name then
    displayName = Player[playerColor].steam_name
  end

  -- add bb-code
  return "[" .. Color.fromString(playerColor):toHex() .. "]" .. displayName .. "[-]"
end

-- creates a deep copy of a table
function deepCopy(data)
  if type(data) ~= "table" then return data end
  local copiedList = {}
  for key, value in pairs(data) do
    if type(value) == "table" then
      copiedList[key] = deepCopy(value)
    else
      copiedList[key] = value
    end
  end
  return copiedList
end

function removeDuplicatesAndSort(t)
  local seen = {}
  local result = {}

  for _, value in ipairs(t) do
    if not seen[value] then
      seen[value] = true
      table.insert(result, value)
    end
  end

  table.sort(result)

  return result
end
